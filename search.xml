<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法0001:MAX[左]-MAX[右]</title>
      <link href="/2021/11/25/0001-max-zuo-max-you/"/>
      <url>/2021/11/25/0001-max-zuo-max-you/</url>
      
        <content type="html"><![CDATA[<h1 id="输入一个数组，数组长度大于等于2，将该数组随机的一分为二，分成左数组右数组，求左数组-右数组的绝对值的最大值"><a href="#输入一个数组，数组长度大于等于2，将该数组随机的一分为二，分成左数组右数组，求左数组-右数组的绝对值的最大值" class="headerlink" title="输入一个数组，数组长度大于等于2，将该数组随机的一分为二，分成左数组右数组，求左数组-右数组的绝对值的最大值"></a>输入一个数组，数组长度大于等于2，将该数组随机的一分为二，分成左数组右数组，求左数组-右数组的绝对值的最大值</h1><p><strong>左程云引例</strong></p><h2 id="关键点：左1和右1是必然被划分到左边一组和右边一组的"><a href="#关键点：左1和右1是必然被划分到左边一组和右边一组的" class="headerlink" title="关键点：左1和右1是必然被划分到左边一组和右边一组的"></a>关键点：左1和右1是必然被划分到左边一组和右边一组的</h2><p>解答：</p><p>没有想法的办法：进行遍历，暴力解法。</p><ol><li>遍历数组得到整个数组中最大值</li><li>比较左1和右1谁小，选择小的，划分为一组，数组中的max划分到另一组</li><li>这样，其中一组包含整个数组中最大的max，另一组包含最左/最右中的较小的那个（此时为组中max），得到的max差值就是最大的差值</li></ol><p>代码示例：(急速版本，未进行优化)</p><pre class="line-numbers language-none"><code class="language-none">public class A0001_max_left_max_right &#123;    &#x2F;&#x2F;max左-max右    &#x2F;&#x2F;描述：把一个数组划分为两个，使得max[左]-max[右]的绝对值达到最大    &#x2F;&#x2F;题解：laogou.github.io    public static void main(String[] args) &#123;        int data[]&#x3D;&#123;342,7,7,84,8,2,65,7,37868,2,77,2435,5&#125;;        int max&#x3D;0;        int max2&#x3D;0;        int result&#x3D;0;        for (int i &#x3D; 0; i &lt; data.length; i++) &#123;            if (data[i]&gt;data[max])&#123;                max&#x3D;i;            &#125;        &#125;        &#x2F;&#x2F;此时max已经取得最大的坐标        &#x2F;&#x2F;当max是最后一位时        if (max&#x3D;&#x3D;0)&#123;            &#x2F;&#x2F;从右边找一个大于最后一位数的            for (int i &#x3D; data.length-2; i &gt; 0; i--) &#123;                if(data[i]&gt;data[data.length-1])&#123;                    max2&#x3D;i;   &#x2F;&#x2F;这里得到区间边界值                &#125;            &#125;            result&#x3D;Math.abs(data[max]-data[data.length-1]); &#x2F;&#x2F;这里得到最终结果        &#125;        else if(max&#x3D;&#x3D;data.length-1)&#123;            &#x2F;&#x2F;从左边找一个大于data[0]的数            for (int i &#x3D; 0; i &lt; data.length - 2; i++) &#123;                if(data[i]&gt;data[0])&#123;                    max2&#x3D;i; &#x2F;&#x2F;得到边界                &#125;            &#125;            result&#x3D;Math.abs(data[max]-data[0]);        &#125;        &#x2F;&#x2F;max是中间某个值的情况        else &#123;            if (data[0]&lt;data[data.length-1])&#123;  &#x2F;&#x2F;如果0位的数比较小                &#x2F;&#x2F;从左边到max中间找一个大于data[0]的数                for (int i &#x3D; 0; i &lt; max - 2; i++) &#123;                    if(data[i]&gt;data[0])&#123;                        max2&#x3D;i; &#x2F;&#x2F;得到边界                    &#125;                &#125;                result&#x3D;Math.abs(data[max]-data[0]);            &#125;            else &#123;                &#x2F;&#x2F;从max到右边之间找一个大于data[length-1]的数                for (int i &#x3D; max; i &lt; data.length-1; i++) &#123;                    if(data[i]&gt;data[data.length-1])&#123;                        max2&#x3D;i; &#x2F;&#x2F;得到边界                    &#125;                &#125;                result&#x3D;Math.abs(data[max]-data[0]);            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 业务分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
