<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode-java基础操作</title>
      <link href="/2022/02/19/leetcode-java-ji-chu-cao-zuo/"/>
      <url>/2022/02/19/leetcode-java-ji-chu-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><ol><li><p>基本知识<br> java中所有的字符串值都是用String类的实例实现，比如： <code>String str = &quot;abc&quot;;</code><br> 等价于<code>String str = new String(new char[]&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;);</code><br> 通过String类的函数和构造函数，可以实现char[], byte[]和String的互转。</p></li><li><p>注意事项</p><p> 字符串本身是常量，在创建后不能更改</p><p> 判断内容相等需要用equals判断(默认是比较地址，但是String类重写了equals方法为比较内容)，直接用==还是比较地址，不能比较内容</p></li><li><p>其他功能</p><p> 替换：<code>&quot;hello&quot;.replace(&quot;l&quot;, &quot;k&quot;)</code></p><p> 去除字符串的两端空格：<code>&quot; hello &quot;.trim() =&gt; &quot;hello&quot;</code></p><p> 字典序排序比较 —— 比较第一个不相等的字符做减法：<code>&quot;habc&quot;.compareTo(&quot;hz&quot;)</code>，相当于<code>&#39;a&#39;-&#39;z&#39;=-25</code></p></li></ol><h2 id="String和Int互转"><a href="#String和Int互转" class="headerlink" title="String和Int互转"></a>String和Int互转</h2><ol><li>Int转字符串</li></ol><pre class="line-numbers language-none"><code class="language-none">System.out.println(String.valueOf(123));System.out.println(123+&quot;&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>字符串转Int</li></ol><pre class="line-numbers language-none"><code class="language-none">System.out.println(Integer.parseInt(“123&quot;));StringBuffer&#x2F;StringBuilder类 - 可变长字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li><p>分类</p><p> StringBuffer 线程安全的可变字符串</p><p> StringBuilder 单线程场景下的可变字符串，所有操作完全一样</p><p> 有capacity()和length()两个概念：空对象的容量为16，长度为0</p></li><li><p>背景</p><p> 一个长字符串拼接时，由于字符串不可更改，这个过程中会生成一大堆String对象<br> 使用StringBuffer/StringBuilder在拼接(append)过程中使用同一对象，内存地址不变！</p></li></ol><pre class="line-numbers language-none"><code class="language-none">String a &#x3D; &quot;&quot;;for(int i&#x3D;0;i&lt;10;i++)&#123;a +&#x3D; i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>常用操作</li></ol><pre class="line-numbers language-none"><code class="language-none">StringBuffer sb &#x3D; new StringBuffer();sb.append(&quot;123&quot;).append(&quot;456&quot;); &#x2F;&#x2F; 追加sb.insert(5, “hi”) &#x2F;&#x2F; 在第5个字符之后插入System.out.println(sb); &#x2F;&#x2F; “12345hi6”StringBuffer&#x2F;StringBuilder和String的互转String &#x3D;&gt; StringBuffer：创建一个空对象，append String进去即可StringBuffer &#x3D;&gt; String：sb.toString() 方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li><p>作为形参使用</p><p> String作为形参要当做基本类型，复制值；</p><p> StringBuffer即为普通的引用类型，形参会改变；</p></li></ol><h2 id="日期类-Date"><a href="#日期类-Date" class="headerlink" title="日期类 Date"></a>日期类 Date</h2><ol><li>获取当前时间戳</li></ol><p><code>new Date().getTime(); // 毫秒，除以1000即是秒</code></p><ol start="2"><li>日期转字符串 - 需要用到SimpleDateFormat类</li></ol><pre class="line-numbers language-none"><code class="language-none">Date d &#x3D; new Date();SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-mm-dd HH:mm:ss&quot;);System.out.println(sdf.format(d));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>字符串转日期</li></ol><pre class="line-numbers language-none"><code class="language-none">SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-mm-dd HH:mm:ss&quot;);try &#123;Date d2 &#x3D; sdf.parse(&quot;2021-08-08 22:08:04&quot;);&#125; catch (ParseException e) &#123;e.printStackTrace();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="随机数-Random"><a href="#随机数-Random" class="headerlink" title="随机数 Random"></a>随机数 Random</h2><ul><li><p>使用默认随机种子(当前毫秒时间戳)：<code>Random r = new Random();</code></p></li><li><p>使用随机种子(相同种子生成相同随机数序列)：<code>Random r = new Random( int seed );</code></p></li><li><p>获取随机数：<code>r.nextInt(n); // 返回[0,n)范围内的随机数</code></p></li><li><p>正则表达式 Pattern/Matcher</p></li></ul><ol><li><p>基本用法</p><p> 用字符串的方法即可，判断目标字符串是否满足正则表达式/按照正则表达式替换</p></li></ol><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 示例的正则，20xx年份String regex &#x3D; &quot;20\\d\\d&quot;;&#x2F;&#x2F; 1. 基本用法，判断是否符合正则的格式System.out.println(&quot;2019&quot;.matches(regex)); &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>进阶用法</p><p> 遍历目标字符串中所有满足正则表达式的子串 和 替换操作</p></li></ol><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 1. 依次找到所有符合条件的字符串并输出Matcher m &#x3D; Pattern.compile(regex).matcher(&quot;2033，2088，1977，哈哈&quot;);while (m.find()) &#123;undefinedSystem.out.println(m.group() + &quot;子串的起始位置：&quot; + m.start() + &quot;，其结束位置：&quot; + m.end());&#125;&#x2F;&#x2F; 2.1 正则匹配后替换，用matcherSystem.out.println(m.replaceAll(&quot;[%year%]&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h2><p>int类型的最大值，最小值(做比较时常用)：<code>Integer.MAX_VALUE, Integer.MIN_VALUE</code></p><h2 id="Math的各类操作："><a href="#Math的各类操作：" class="headerlink" title="Math的各类操作："></a>Math的各类操作：</h2><p>最大/最小/绝对值(支持int，float，double等各数值类型)：</p><pre class="line-numbers language-none"><code class="language-none">Math.max(a,b);Math.min(a,b);Math.abs(a);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求幂：</p><p><code>Math.pow(double a, double b) // a的b次方</code></p><p>求平方跟：</p><p><code>Math.sqrt(double a) // a开根号</code></p><h1 id="集合-泛型"><a href="#集合-泛型" class="headerlink" title="集合/泛型"></a>集合/泛型</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol><li><p>基础知识</p><p> 是一种将明确类型的工作推迟到创建对象或者调用方法时才去明确的特殊类型。</p><p> 避免了由于对集合使用Object代表任意类型，导致容器中对象类型前后不一致的问题：在编译时报错</p><p> 只能用于引用类型，不能用于基本类型(用包装类替代，如Integer，Character代替int, char)。</p><p> 一般在集合中使用，比如List l = new ArrayList&lt;&gt;();</p><p> 根据指定泛型的具体类型的位置区分：</p><p> 泛型类：public class ObjectTool{}</p><p> 泛型接口：public interface ObjectInt{}</p><p> 泛型方法：public objectMethod(T t){}</p></li><li><p>高级通配符</p></li></ol><p>假设 Class Dog extends Animal {}  </p><p>?：表示任意类  </p><p>? extends E：向下限定，需要是E及其子类，比如List extends Animal&gt; l = new ArrayList();  </p><p>? super E：向上限定，需要是E及其父类，比如List super Animal&gt; l = new ArrayList();  </p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><p>为了方便对于多个对象的操作，提供了集合：和数组的区别在于，数组长度固定而集合长度可变。</p></li><li><p>集合只存储对象(用包装类，比如Integer，Character代替基础数据类型)。</p></li><li><p>可使用迭代器遍历集合：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">Iterator i &#x3D; a.iterator();while(i.hasNext())&#123;undefinedSystem.out.println(i.next());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="集合介绍和常见操作"><a href="#集合介绍和常见操作" class="headerlink" title="集合介绍和常见操作"></a>集合介绍和常见操作</h3><ol><li>Map 字典</li></ol><ul><li>初始化操作<code>Map m = new HashMap&lt;&gt;(); // 最常用，线程不安全的哈希表；线程安全可用ConcurrentHashMap</code></li><li>遍历操作<pre class="line-numbers language-none"><code class="language-none">for (Map.Entry entry : map.entrySet()) &#123;System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>读写操作</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 正常写入map.put(k,v);&#x2F;&#x2F; value为容器时写入空map.putIfAbsent(key, new ArrayList&lt;&gt;());&#x2F;&#x2F; 正常读map.get(k);&#x2F;&#x2F; 带默认值的读map.getOrDefault(domTreat,0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>List 列表</li></ol><ul><li>初始化操作</li></ul><pre class="line-numbers language-none"><code class="language-none">List result &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 基于数组实现的列表；基于链表实现LinkedList<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>遍历操作</li></ul><pre class="line-numbers language-none"><code class="language-none">for ( String tmp: l ) &#123;undefinedSystem.out.println(tmp);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>读写操作</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 添加：list.add(Object a);list.set(int idx, Object a);&#x2F;&#x2F; 读：list.get(int idx);&#x2F;&#x2F; 删除：list.remove(Object a); list.remove(int idx);&#x2F;&#x2F; 排序：Collections.sort(list, (a,b) -&gt; a.compareTo(b))&#x2F;&#x2F; 逆序：Collections.reverse(list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>Stack 栈</li></ol><ul><li>初始化操作</li></ul><pre class="line-numbers language-none"><code class="language-none">Stack &#x3D; new Stack&lt;&gt;(); &#x2F;&#x2F; 基于Vector实现(List的一种，底层为数组)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>入栈/出栈操作</li></ul><pre class="line-numbers language-none"><code class="language-none">T pop() &#x2F;&#x2F; 出栈push(T t) &#x2F;&#x2F; 入栈T peek() &#x2F;&#x2F; 获取栈顶<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>Queue 队列</li></ol><ul><li>初始化操作</li></ul><pre class="line-numbers language-none"><code class="language-none">Queue &#x3D; new LinkedList&lt;&gt;(); &#x2F;&#x2F; LinkedList实现了Queue接口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>入队/出队操作</li></ul><pre class="line-numbers language-none"><code class="language-none">offer(T t) &#x2F;&#x2F; 加入到队尾T poll() &#x2F;&#x2F; 队列头出队T peek() &#x2F;&#x2F; 获取队列头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>PriorityQueue 堆</li></ol><ul><li>初始化操作</li></ul><pre class="line-numbers language-none"><code class="language-none">PriorityQueue heap &#x3D; new PriorityQueue&lt;&gt;((a,b)-&gt;a-b);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>构造函数中为使用lambda表达式简化Comparator的写法</li></ul><p>用于表明a和b的关系，如上所示就是小根堆  </p><ul><li>入堆/出堆操作</li></ul><pre class="line-numbers language-none"><code class="language-none">offer(T t) &#x2F;&#x2F; 加入到堆中T poll() &#x2F;&#x2F; 删除堆顶T peek() &#x2F;&#x2F; 获取堆顶<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li>声明和初始化</li></ol><ul><li>动态声明：给定长度并通过new关键字申请内存空间，系统用默认值初始化(比如int是0)：</li></ul><pre class="line-numbers language-none"><code class="language-none">int[] a &#x3D; new int[5];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>通过字面量声明：</li></ul><pre class="line-numbers language-none"><code class="language-none">int[] t &#x3D; new int[]&#123;1,2,3,4&#125;;可以简写为 int []a &#x3D; &#123;1,2,3,4,5&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>打印：</li></ol><ul><li><p>直接打印是出内存地址：System.out.println(array);</p></li><li><p>一维数组可以用容器方法转换：System.out.println(Arrays.toString(array));</p></li></ul><ol start="3"><li>赋值：数组为引用类型，存储在堆上，所以赋值是给的内存地址</li></ol><pre class="line-numbers language-none"><code class="language-none">int[] t &#x3D; new int[5];int[] s &#x3D; t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>遍历：</li></ol><pre class="line-numbers language-none"><code class="language-none">for(int i&#x3D;1;iSystem.out.println(nums[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>可变长参数</li></ol><p>参数长度可变化，在方法内获取参数时实际上就是数组</p><pre class="line-numbers language-none"><code class="language-none">public void testParams(int... a)&#123;undefinedfor(int x:a)&#123;undefinedSystem.out.println(a);&#125;&#125;testParam(1,2,3,4,5); &#x2F;&#x2F; 使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解笔记</title>
      <link href="/2022/01/02/leetcode-ti-jie-bi-ji/"/>
      <url>/2022/01/02/leetcode-ti-jie-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>本片文章为leetcode做题中的一些笔记和思路（技巧性）  </p><ul><li>leetcode138：复杂链表（随机指针）的复制<br>方法一：借助辅助空间：hashmap，然后键值对为&lt;旧节点，新节点&gt;然后对旧节点进行遍历，同时为新节点设置next和random_next。此方法依赖额外的O(n)的辅助空间。<br>方法二：操作一下。首先新复制n个节点（值），放在原节点的后面，使之串成一个大链表（原来1-&gt;2，后来1-&gt;1’-&gt;2-&gt;2’），然后对整条链表根据一对一对的，遍历过程中为新节点设置和旧节点一样的random_next。最后拆分开来就可以。</li><li>leetcode142：环形链表<br>若链表有环，在空间复杂为O(1)下找出入环节点：快慢指针，快指针一次两步，慢指针一次一步。如果有环难么他俩一定相遇，没环，则快指针会null。有环之后，慢指针停留在原地，快指针去开头，两个一起往前走（一次一步），则他们一定会在环的入口处相遇。返回即可。  </li><li>leetcode：环形链表相交：<br>两个链表，可能有或者没有环，判断是否相交以及交点问题：首先用leetcode142问题中的找链表的环入口，得到两个链表的环（可能存在）入口loop1和loop2。然后分情况进行处理。  <ul><li>情况1：loop1和loop2都是null，这就转化成两个无环链表相交问题。  </li><li>情况2：loop1和loop2一个为空，一个不为空，这种情况两个链表一定不相交。因为只要有环一定共用环。  </li><li>情况3：loop1和loop2都不为空，那么肯定共用环，分情况处理。  <ul><li>当loop1==loop2时，分为两种情况，一种是两个链表的共同入环节点也是交点，一种是在共同入环之前就相交。这两种都转化为两个无环链表相交问题。</li><li>当loop1!=loop2时，保持loop1不动，loop2向前进，会相遇到loop1的位置，反之亦然。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库复习</title>
      <link href="/2021/12/20/shu-ju-ku-fu-xi/"/>
      <url>/2021/12/20/shu-ju-ku-fu-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h2><p>查看当前使用的是哪个库？<code>selece database()</code>像是java中的一个类的方法，实际上是mysql的功能函数。<br>创建一个数据库<code>create database 数据库名</code>，创建一个表：</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基数排序和桶排序</title>
      <link href="/2021/12/05/qi-shu-pai-xu-he-tong-pai-xu/"/>
      <url>/2021/12/05/qi-shu-pai-xu-he-tong-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>基数道理都懂，本章节中进行了部分优化，包括前缀数量和，从右往左进行进出，线性预测顺序进行排放等。以下是代码部分：</p><pre class="line-numbers language-none"><code class="language-none">package class01;&#x2F;** * Creat by zhangzhiyuan * Date 2021&#x2F;12&#x2F;5 * Time 16:29 * 基数排序代码 *&#x2F;public class Code12_RadixSort &#123;    &#x2F;&#x2F;only for no-negative value    public static void radixSort(int[] arr)&#123;        if (arr&#x3D;&#x3D;null || arr.length &lt;2)&#123;            return;        &#125;        radixSort(arr,0,arr.length-1,maxbits(arr));    &#125;    &#x2F;&#x2F;基数排序，对arr[begin...end]排序    public static void radixSort(int[]arr, int L,int R, int dight)&#123;        final int radix&#x3D;10; &#x2F;&#x2F;永远是10进制        int i&#x3D;0,j&#x3D;0;        &#x2F;&#x2F;有多少个数准备多少个辅助空间        int[]bucket&#x3D;new int[R-L+1];        for (int d &#x3D; 1; d &lt;&#x3D; dight; d++) &#123;  &#x2F;&#x2F;有多少位就进出几次            &#x2F;&#x2F;10个空间            &#x2F;&#x2F;count[0] 当前位（d位）是0的数字有多少个            &#x2F;&#x2F;count[1] 当前位（d位）是0、1的数字有多少个            &#x2F;&#x2F;count[2] 当前位（d位）是0、1、2的数字有多少个            &#x2F;&#x2F;可以叫做前缀和数量            int[]count&#x3D;new int[radix]; &#x2F;&#x2F;count[0...9]            &#x2F;&#x2F;词频统计            for ( i &#x3D; L; i &lt;&#x3D;R ; i++) &#123;                j&#x3D;getDigit(arr[i],d);  &#x2F;&#x2F;d是1的话就取出个位数字                count[j]++;            &#125;            &#x2F;&#x2F;count处理为前缀和的形式            for ( i &#x3D; 1; i &lt;radix ; i++) &#123;                count[i]+&#x3D;count[i-1];            &#125;            &#x2F;&#x2F;数组从右往左遍历            for (i &#x3D; R; i &gt;&#x3D;L ; i--) &#123;                j&#x3D;getDigit(arr[i],d);                bucket[count[j]-1]&#x3D;arr[i];                count[j]--;   &#x2F;&#x2F;各位数字出桶，放到了bucket辅助数组里边            &#125;            for (i &#x3D; L,j&#x3D;0; i &lt;&#x3D;R ; i++,j++) &#123;  &#x2F;&#x2F;相当于维持了本次桶排序的结果，然后再下一次出桶入桶                arr[i]&#x3D;bucket[j];            &#125;        &#125;    &#125;    &#x2F;&#x2F;找出最大值，然后看它有几个进制位    public static int maxbits(int[] arr)&#123;        int max&#x3D;Integer.MIN_VALUE;        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;            max&#x3D;Math.max(max,arr[i]);        &#125;        int res&#x3D;0;        while (max!&#x3D;0)&#123;            res++;            max&#x2F;&#x3D;10;        &#125;        return res;    &#125;    &#x2F;&#x2F;获取一个数的第d位数    public static int getDigit(int x, int d)&#123;        return ((x&#x2F;((int) Math.pow(10,d-1)))%10);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较器</title>
      <link href="/2021/12/04/bi-jiao-qi/"/>
      <url>/2021/12/04/bi-jiao-qi/</url>
      
        <content type="html"><![CDATA[<p>比较器在C++里和重载运算符含义相同。</p><pre class="line-numbers language-none"><code class="language-none">package class01;import java.util.Arrays;import java.util.Comparator;import java.util.PriorityQueue;&#x2F;** * Creat by zhangzhiyuan * Date 2021&#x2F;12&#x2F;4 * Time 23:25 *&#x2F;public class Code11_MyComparator &#123;    &#x2F;&#x2F;需要的学生类    public static class Student &#123;        public String name;        public int id;        public int age;        public Student(String name, int id, int age) &#123;            this.name &#x3D; name;            this.id &#x3D; id;            this.age &#x3D; age;        &#125;    &#125;    public static class IdAscendingComparator implements Comparator&lt;Student&gt; &#123;        @Override        public int compare(Student o1, Student o2) &#123;            &#x2F;&#x2F;返回负数，第一个参数排在前面            &#x2F;&#x2F;返回正数，第二个参数排在前面            &#x2F;&#x2F;返回0，无所谓            return o1.id - o2.id;        &#125;    &#125;    public static class IdDescendingComparator implements Comparator&lt;Student&gt; &#123;        @Override        public int compare(Student o1, Student o2) &#123;            return o2.id - o1.id;        &#125;    &#125;    public static class AgeAscendingComparator implements Comparator&lt;Student&gt; &#123;        @Override        public int compare(Student o1, Student o2) &#123;            return o1.age - o2.age;        &#125;    &#125;    public static class AgeDescendingComparator implements Comparator&lt;Student&gt; &#123;        @Override        public int compare(Student o1, Student o2) &#123;            return o2.age - o1.age;        &#125;    &#125;    public static void printStudents(Student[] students) &#123;        for (Student student : students) &#123;            System.out.println(&quot;Name : &quot; + student.name + &quot;, Id : &quot; + student.id + &quot;, Age : &quot; + student.age);        &#125;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;    public static void main(String[] args) &#123;        Student student1 &#x3D; new Student(&quot;A&quot;, 1, 23);        Student student2 &#x3D; new Student(&quot;B&quot;, 2, 21);        Student student3 &#x3D; new Student(&quot;C&quot;, 3, 22);        Student[] students &#x3D; new Student[] &#123; student3, student2, student1 &#125;;        printStudents(students);        &#x2F;&#x2F;系统排序，把数组给它，把策略给它，就可以按照策略堆数组进行排序        Arrays.sort(students, new IdAscendingComparator());        printStudents(students);        Arrays.sort(students, new IdDescendingComparator());        printStudents(students);        Arrays.sort(students, new AgeAscendingComparator());        printStudents(students);        Arrays.sort(students, new AgeDescendingComparator());        printStudents(students);        &#x2F;&#x2F;自带的堆结构        PriorityQueue&lt;Student&gt; heap &#x3D; new PriorityQueue&lt;&gt;(new AgeAscendingComparator());        heap.add(student1);        heap.add(student2);        heap.add(student3);        while (!heap.isEmpty())&#123;            Student student &#x3D; heap.poll();            System.out.println(&quot;Name : &quot; + student.name + &quot;, Id : &quot; + student.id + &quot;, Age : &quot; + student.age);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>带比较器，使得制定构建大根堆或者小根堆，并支持自定义的数据结构（类）：  </p><pre class="line-numbers language-none"><code class="language-none">package class01;import java.util.Comparator;import java.util.PriorityQueue;&#x2F;** * Creat by zhangzhiyuan * Date 2021&#x2F;12&#x2F;4 * Time 22:56 * 建小根堆，给几乎有序的数据进行排序，距离不超过K *&#x2F;public class Code10_SortArrayDistanceLessK &#123;    public static class ACom implements Comparator&lt;Integer&gt; &#123;        &#x2F;&#x2F;如果返回负数，认为第一个参数应该在上面        &#x2F;&#x2F;如果返回负数，认为第二个参数应该在上面        &#x2F;&#x2F;如果返回0，无所谓        @Override        public int compare(Integer arg0, Integer arg1) &#123;            return arg1-arg0;  &#x2F;&#x2F;做一个大根堆的比较器        &#125;    &#125;    public void sortArrayDistanceLessK(int[] arr,int k) &#123;        &#x2F;&#x2F;默认小根堆        PriorityQueue&lt;Integer&gt; heap &#x3D; new PriorityQueue&lt;&gt;();        int index&#x3D;0;        &#x2F;&#x2F;建一个小堆，前k个数放进去        for ( ;index &lt;&#x3D; Math.min(arr.length,k); index++) &#123;            heap.add(arr[index]);        &#125;        int i&#x3D;0;        for ( ;index&lt;arr.length ; i++,index++) &#123;            heap.add(arr[index]);            arr[i]&#x3D;heap.poll();        &#125;        while (!heap.isEmpty())&#123;            arr[i++]&#x3D;heap.poll();        &#125;    &#125;    public static void main(String[] args) &#123;        &#x2F;&#x2F;优先级队列，底层就是堆,可以直接用其来建堆，并且建堆的复杂度都是O（N），扩容的复杂度为（均摊）O(logn)，不影响整体表现。        PriorityQueue&lt;Integer&gt; heap &#x3D; new PriorityQueue&lt;&gt;(); &#x2F;&#x2F;默认为大根堆        heap.add(123); &#x2F;&#x2F;添加一个元素        heap.poll();&#x2F;&#x2F;弹出并移除最大值。        &#x2F;&#x2F;有时候必须要手写堆，因为系统堆不能够支持一些操作（修改某个元素值，然后重新调整，系统会从头扫描，不会从那个元素直接操作）        &#x2F;&#x2F;如果想改为小根堆，那么需要传入一个比较器        PriorityQueue&lt;Integer&gt; heap1 &#x3D; new PriorityQueue&lt;&gt;(new ACom());        heap1.add(6);        heap1.add(9);        heap1.add(3);        heap1.add(2);        heap1.add(10);        while (!heap.isEmpty())&#123;            System.out.println(heap.poll());        &#125;        &#x2F;&#x2F;还可以自定义一个复杂的比较器。年龄，id，班级（适用于自定义的类）    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基于比较排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序及改进</title>
      <link href="/2021/12/04/dui-pai-xu-ji-gai-jin/"/>
      <url>/2021/12/04/dui-pai-xu-ji-gai-jin/</url>
      
        <content type="html"><![CDATA[<p>堆排序常用代码：  </p><pre class="line-numbers language-none"><code class="language-none">package class01;&#x2F;** * Creat by zhangzhiyuan * Date 2021&#x2F;12&#x2F;4 * Time 17:04 * 堆排序，假设数组长度N，时间复杂度为nlogn（建堆等），空间复杂度O(1) *&#x2F;public class Code09_HeapSort &#123;    public static void swap(int[] arr,int i, int j)&#123;        int tmp&#x3D;arr[i];        arr[i]&#x3D;arr[j];        arr[j]&#x3D;tmp;    &#125;    &#x2F;&#x2F;向上    public static void heapInsert(int[] arr,int index) &#123;        while (arr[index] &gt; arr[(index-1)&#x2F;2])&#123;            &#x2F;&#x2F;子位置比父位置的数大，就进行交换            swap(arr,index,(index-1)&#x2F;2);            index&#x3D;(index-1)&#x2F;2;   &#x2F;&#x2F;指针再移动到父位置，准备继续寻找        &#125;    &#125;    &#x2F;&#x2F;某个数在index位置，判断能否往下移动    public static void heapify(int[] arr, int index, int heapSize)&#123;        int left&#x3D;index*2+1; &#x2F;&#x2F;左孩子        while (left&lt;heapSize)&#123;  &#x2F;&#x2F;下方还有孩子的时候            &#x2F;&#x2F;两个孩子中，选择出大的那个和父交换            int largest&#x3D; ((left+1 &lt; heapSize) &amp;&amp; (arr[left+1] &gt; arr[left])) ? left+1 : left;  &#x2F;&#x2F;把孩子中较大的下标给largest            largest&#x3D;arr[largest]&gt;arr[index]?largest:index; &#x2F;&#x2F;父亲和孩子之间，谁的值大，把下标给largest            if (largest &#x3D;&#x3D; index)&#123;                break;            &#125;            swap(arr,largest,index);            index&#x3D;largest;            left&#x3D;index*2+1;        &#125;    &#125;    &#x2F;&#x2F;heap操作添加一个数据，调整级别是logn级别的    &#x2F;&#x2F;堆排序    public static void heap(int[] arr) &#123;        &#x2F;&#x2F;调整大根堆的操作~逐步增加数据，从0个开始增加数据，相当于逐步插入数据。        &#x2F;&#x2F;删除堆顶，相当于把最后一个和堆顶交换，然后heapsize--，然后调整，这相当于删除了一个元素。        if (arr&#x3D;&#x3D;null || arr.length&lt;2)&#123;            return;        &#125;&#x2F;&#x2F;方法1，常规思路，下面有优化        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;            heapInsert(arr,i);        &#125;        int heapSize&#x3D;arr.length;        swap(arr,0,--heapSize);        while (heapSize &gt; 0) &#123;            heapify(arr,0,heapSize);            swap(arr,0,--heapSize);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思考：当用户给我一个数组，可以把他默认为一个堆，然后从下往上进行heapfy调整。逐渐形成一个个小堆，然后上面进行一个heapfy，最后构成整个堆。<br>证明：N个数组成的树，叶子节点大约有N/2个，从他们开始向下进行调整时，复杂度为O(1),倒数第二层节点为N/4个，向下调整复杂度为2，累加之后整体复杂度为<code>T(N)=N/2 *1 + N/4 *2 + N/8 *3 +...</code>，2Tn-Tn，错位相减，估计后为时间复杂度为O(n)  </p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;方法2：当用户给我一个数组，可以把他默认为一个堆，然后从下往上进行heapfy调整。逐渐形成一个个小堆，然后上面进行一个heapfy，最后构成整个堆，证明见博客       for (int i &#x3D; arr.length-1; i &gt;&#x3D;0 ; i--) &#123;           heapify(arr,i, arr.length);       &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>堆结构永远比堆排序重要。</li><li>优先级队列就是堆，不是队列。认为堆顶是优先级最大的<br>例题：有一个几乎有序的数组，几乎有序是指：一个数移动到它应该所在的位置，距离不超过k。并且k相对数组长度来说较小。<br>解答：如果k为6，那么准备一个长度为7的小根堆，然后堆顶就是最小值（因为7位置后面的距离0位置超过6，故不可能为最大值），然后从第8个开始，挨个放到小根堆中，然后选出堆顶，这就是第二小的，然后再拿一个放到小根堆中……这样复杂度为O(N*logK)<pre class="line-numbers language-none"><code class="language-none">package class01;import java.util.PriorityQueue;&#x2F;** * Creat by zhangzhiyuan * Date 2021&#x2F;12&#x2F;4 * Time 22:56 * 建小根堆，给几乎有序的数据进行排序，距离不超过K *&#x2F;public class Code10_SortArrayDistanceLessK &#123;    public void sortArrayDistanceLessK(int[] arr,int k) &#123;        &#x2F;&#x2F;默认小根堆        PriorityQueue&lt;Integer&gt; heap &#x3D; new PriorityQueue&lt;&gt;();        int index&#x3D;0;        &#x2F;&#x2F;建一个小堆，前k个数放进去        for ( ;index &lt;&#x3D; Math.min(arr.length,k); index++) &#123;            heap.add(arr[index]);        &#125;        int i&#x3D;0;        for ( ;index&lt;arr.length ; i++,index++) &#123;            heap.add(arr[index]);            arr[i]&#x3D;heap.poll();        &#125;        while (!heap.isEmpty())&#123;            arr[i++]&#x3D;heap.poll();        &#125;    &#125;    public static void main(String[] args) &#123;        &#x2F;&#x2F;优先级队列，底层就是堆,可以直接用其来建堆，并且建堆的复杂度都是O（N），扩容的复杂度为（均摊）O(logn)，不影响整体表现。        PriorityQueue&lt;Integer&gt; heap &#x3D; new PriorityQueue&lt;&gt;();        heap.add(123); &#x2F;&#x2F;添加一个元素        heap.poll();&#x2F;&#x2F;弹出并移除最大值。        &#x2F;&#x2F;有时候必须要手写堆，因为系统堆不能够支持一些操作（修改某个元素值，然后重新调整，系统会从头扫描，不会从那个元素直接操作）    &#125;&#125;&#96;&#96;&#96;  引例：输出流的中位数  * 题意：一个流不断的吐出数，吐出的过程会询问中位数的值。  * 解法：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>维护大根堆，里面放的是吐出来偏小的数。<br>维护小根堆，里面是偏大的数。<br>每次询问就查询两个堆顶即可。<pre class="line-numbers language-none"><code class="language-none">* 维护策略：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>一个数如果比大根堆（里面是小的数）的堆顶小，那么insert到这个堆。另一个堆同理。<br>当两个堆的size相差&gt;1 ，就把size大的堆的堆顶弹出，加入到另一个堆中。<br>```</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基于比较排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快排+随机数V3.0</title>
      <link href="/2021/12/04/kuai-pai-sui-ji-shu-v3-0/"/>
      <url>/2021/12/04/kuai-pai-sui-ji-shu-v3-0/</url>
      
        <content type="html"><![CDATA[<p>最初版本的快排已经是非常了解，但是最坏的情况时间复杂度为O(n^2)，现在通过分三段加上随机数，这样就形成了快排3.0版本，时间复杂度为O(nlogn)，空间复杂度为O(logn)。代码如下，可当作一个模板使用  </p><pre class="line-numbers language-none"><code class="language-none">package class01;&#x2F;** * Creat by zhangzhiyuan * Date 2021&#x2F;12&#x2F;3 * Time 16:34 * 快排3.0版本+随机数 *&#x2F;public class Code06_QuickSort &#123;    public static void quickSort(int[] arr) &#123;        if (arr&#x3D;&#x3D;null || arr.length&lt;2)&#123;            return;        &#125;        quickSort(arr,0,arr.length-1);    &#125;    public static void quickSort(int[]arr,int L,int R)&#123;        if (L&lt;R)&#123;            swap(arr,L+(int)(Math.random()*(R-L+1)),R); &#x2F;&#x2F;选出一个随机位置和最后一位交换，作为partition            int[]p&#x3D;partition(arr,L,R); &#x2F;&#x2F;返回的这个数组长度一定为2，是等于划分值（标志位）的左边界和右边界            quickSort(arr,L,p[0]-1);  &#x2F;&#x2F;这里的p[0]是中间等于划分值区域的左边界            quickSort(arr,p[0]+1,R);    &#x2F;&#x2F;这里的p[1]是中间等于划分值区域的右边界        &#125;    &#125;    public static void swap(int[] arr,int i, int j)&#123;        int tmp&#x3D;arr[i];        arr[i]&#x3D;arr[j];        arr[j]&#x3D;tmp;    &#125;    &#x2F;&#x2F;这是一个处理arr[l....R]的函数    &#x2F;&#x2F;默认以arr[r]做划分，arr[r]-&gt;p    &#x2F;&#x2F;返回等于区域（左边界，右边界），所以返回一个长度为2的数组res,res[0] res[1]    public static int[] partition(int[]arr,int L,int R)&#123;        int less&#x3D;L-1;        int more&#x3D;R;        while (L&lt;more)&#123;            if (arr[L]&lt;arr[R])&#123;                swap(arr,++less,L++);            &#125; else if (arr[L] &gt; arr[R]) &#123;                swap(arr,--more,L);            &#125;            else &#123;                L++;            &#125;        &#125;        swap(arr,more,R);        return new int[]&#123;less+1,more&#125;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基于比较排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小和问题和逆序对问题</title>
      <link href="/2021/12/02/xiao-he-wen-ti-he-ni-xu-dui-wen-ti/"/>
      <url>/2021/12/02/xiao-he-wen-ti-he-ni-xu-dui-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="归并排序的拓展"><a href="#归并排序的拓展" class="headerlink" title="归并排序的拓展"></a>归并排序的拓展</h2><ul><li>小和问题描述：<br>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和，求一个数组的小和。<br>[1,3,4,2,5]，3左边比3小的数1，4左边比4小的数13，5左边比5小的数1342，所以小和为1+1+3+1+1+3+4+2=16  </li><li>思路：<br>暴力解法，时间复杂度O(n2)。<br>使用归并的思想解题，可以在merge的过程中就能够求出所有的小和。<br>换一种思路，某个数右边有多少个数比它大，那么它就会有多少次计算到小和中。可以使用归并，复杂度nlogn。详细过程：&lt;<a href="https://www.bilibili.com/video/BV1q34y1S7G1?p=3&spm_id_from=pageDriver">详细过程</a>&gt;1:07:00<br>小和问题代码，根据左程云思路描写。<pre class="line-numbers language-none"><code class="language-none">public class Code05_SmallSum &#123;    public static int smallSum(int[] arr) &#123;        if (arr.length&#x3D;&#x3D;0 || arr.length&lt;2)&#123;            return 0;        &#125;        int L&#x3D;0,R&#x3D;arr.length-1;        return process(arr,L,R);    &#125;    &#x2F;&#x2F;既要排好，又要计算小和    public static int process(int[]arr, int L, int R)&#123;        if (L&#x3D;&#x3D;R)&#123;            return 0;        &#125;        int M&#x3D;L+((R-L)&gt;&gt;1); &#x2F;&#x2F;中间值        return process(arr, L,M)+ process(arr,M+1,R)+merge(arr,L,M,R);    &#125;    public static int merge(int[]arr,int L,int M, int R)&#123;        int sum&#x3D;0;        int p1&#x3D;L,p2&#x3D;M+1;        int[]help&#x3D;new int[R-L+1];        int i&#x3D;0;        while (p1&lt;&#x3D;M &amp;&amp; p2&lt;&#x3D;R)&#123;            sum+&#x3D;arr[p1]&lt;arr[p2]?(R-p2+1)*arr[p1]:0;  &#x2F;&#x2F;因为右侧是有序的，所以如果第一个数大，那么后面的数都会大。            help[i++]&#x3D; arr[p1]&lt;arr[p2]?arr[p1++]:arr[p2++]; &#x2F;&#x2F;和普通归并一点不同的是，当左右相等时，首先拷贝右边的，因为这样不会产生小和。            &#x2F;&#x2F;help[i++]&#x3D; arr[p1]&lt;&#x3D;arr[p2]?arr[p1++]:arr[p2++]  &#x2F;&#x2F;这是普通归并，只要前面数组第一个数不大于后面数组第一个数就把前面数放入，而求小和，需要完全小于        &#125;        while (p1&lt;&#x3D;M)&#123;            help[i++]&#x3D;arr[p1++];        &#125;        while (p2&lt;&#x3D;R)&#123;            help[i++]&#x3D;arr[p2++];        &#125;        for (int j &#x3D; 0; j &lt; help.length; j++) &#123;            arr[L+i]&#x3D;help[i];        &#125;        return sum;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>逆序对问题描述（趁热打铁）<br>在一个数组中，左边的数比右边的数大，则两个数构成一个逆序对，打印所有逆序对。</li><li>解题：<br>使用归并解法，可以在merge的过程中就能够求出所有的小和。合并时，当前一个数大于后一个数，那么，前一个数与后面所有的数都组成一个逆序对，<code>ans+=(R-p2+1);</code>，注意当一样大的时，要放选择后面数组的第一个数放下，这样才不会漏解。  <pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int reversePairs(int[] nums) &#123;        if (nums&#x3D;&#x3D;null || nums.length&lt;2)&#123;            return 0;        &#125;        int L&#x3D;0,R&#x3D;nums.length-1;        return process(nums,L,R);    &#125;    public int process(int[] nums,int L, int R) &#123;        if (L&#x3D;&#x3D;R)&#123;            return 0;        &#125;        int M&#x3D;L+((R-L)&gt;&gt;1);        return process(nums,L,M)+process(nums,M+1,R)+merge(nums,L,M,R);    &#125;    public int merge(int[]nums, int L,int M, int R)&#123;        if (L&#x3D;&#x3D;R)&#123;            return 0;        &#125;        int p1&#x3D;L,p2&#x3D;M+1;        int ans&#x3D;0;        int i&#x3D;0;        int[]help&#x3D;new int[R-L+1];        while (p1&lt;&#x3D;M &amp;&amp; p2&lt;&#x3D;R)&#123;            if (nums[p1]&gt;nums[p2])&#123;                ans+&#x3D;(R-p2+1);                help[i++]&#x3D;nums[p1++];            &#125;            else if (nums[p1]&lt;nums[p2])&#123;                help[i++]&#x3D;nums[p2++];            &#125;            else &#123;                help[i++]&#x3D;nums[p2++];            &#125;        &#125;        while (p1&lt;&#x3D;M)&#123;            help[i++]&#x3D;nums[p1++];        &#125;        while (p2&lt;&#x3D;R)&#123;            help[i++]&#x3D;nums[p2++];        &#125;        for (int j &#x3D; 0; j &lt; help.length; j++) &#123;            nums[L+j]&#x3D;help[j];        &#125;        return ans;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>此题是剑指offer 51题，我解答成功。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OJ常用方法</title>
      <link href="/2021/12/02/oj-chang-yong-dai-ma/"/>
      <url>/2021/12/02/oj-chang-yong-dai-ma/</url>
      
        <content type="html"><![CDATA[<ul><li>定义数据结构<pre class="line-numbers language-none"><code class="language-none">Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;Integer&gt;(); &#x2F;&#x2F;定义栈，不确定Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;&gt;(); &#x2F;&#x2F;定义队列HashMap&lt;Node, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F;定义哈希表 List&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;(); &#x2F;&#x2F;定义列表（不定长数组）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>求中点：<pre class="line-numbers language-none"><code class="language-none">旧：int mid&#x3D;(L+R)&#x2F;2   &#x2F;&#x2F;可能L+R会溢出新：int mid&#x3D;L+((R-L)&gt;&gt;1);&#x2F;&#x2F;中点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><hr><ul><li>master公式估计复杂度 T(N)=a*T(N/b)+O(N^d)<br>T(N)是母问题的数据量，T(N/b)是子问题的规模（相同），a是调用次数，O(N^d)是除了调用之外剩下的时间复杂度。<br>这样的递归可以统一用master公式求解复杂度。</li></ul><ol><li>log(b,a)&gt;d -&gt;复杂度为O(N^log(b,a))</li><li>log(b,a)=d -&gt;复杂度为O(N^d * logN)</li><li>log(b,a)&lt;d -&gt;复杂度为O(N^d)<br>例：code08中的求最大值行为，满足master公式：T(N)=2*T(N/2)+O(1)，即a=2，b=2，d=0，只要子问题复杂度一致的（左侧1/3，右侧2/3，就不可以用），复杂度可以直接求。  </li></ol><ul><li><p>判断一个数是不是2的幂次方</p><pre class="line-numbers language-none"><code class="language-none">n&amp;(n-1) &#x2F;&#x2F;结果为0则n为2的幂次方<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进而判断一个数是不是4的幂次方，如果是，则其二进制中只有一个1，并在偶数位上。如何快速判断在偶数位上？<code>mask=AAAAAAAA</code>然后用n和他进行&amp;运算，mask=101010101010….  </p></li><li><p>哈希表与有序表<br>哈希表是一种集合结构，无序。只有key的叫做HashSet，有key、value的叫做HashMap，基础类型按值传递，自定义类型是引用传递。增删改查都是常数级别的。<br>有序表是一种集合结构，有序。只有key的叫做TreeSet，有key、value的叫做TreehMap。他们的内部是按照key有序组织，要求key可以比较，非基础类型必须提供比较器。logN级别  </p><pre class="line-numbers language-none"><code class="language-none">firstkey();&#x2F;&#x2F;最小key的元素contiainsKey(K key);&#x2F;&#x2F;询问是否有关于key的记录lastkey();&#x2F;&#x2F;最大key的元素floorkey(8);&#x2F;&#x2F;小于等于8中，离8最近的元素，表中可以没有8ceilingKey(8);&#x2F;&#x2F;大于等于8中，离8最近的元素ceilingKey(K key);&#x2F;&#x2F;表中存入过key，返回key，否则返回所有键值排序结果中，key的最后一个。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>红黑树，AVL树，傻逼树，跳表都可以实现有序表  </p></li><li><p>链表<br>快慢指针：用于获取链表的长度等，慢指针一次走一步，快指针一次走两步，这样就不必O(n)+O(n/2)的时间复杂度来找到一个链表中间的位置了，而是O(n/2)。<br>对于快慢指针，我们需要订制一些东西，比如当奇数个时，希望慢指针在中点位置，当偶数个时，希望指针在中点（不存在）的前一个或者后一个。<br>更特殊的，我希望在中点的前两个位置，需要快指针多走一步。等边界条件，需要手动编写多练习。单链表的一些笔试题目，可以先放到数组（元素是ListNode不是value值）里，然后在数组里玩partition。  </p></li></ul><p>六变量处理partition的最后判断过程：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;已有sH、sT、eH、eT、mH、mT：小于等于大于分界值的头尾节点，最后的判断连接问题if(sT!&#x3D;null)&#123;sT.next&#x3D;eH;eT&#x3D; eT&#x3D;&#x3D;null?sT:eT;&#125;if(eT!&#x3D;null)&#123;eT.next&#x3D;mH;&#125;return sH!&#x3D;null?sH:(eH!&#x3D;null?eH:mH);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断一个链表中有没有环：快慢指针，起始位置相同，快指针一次走两步，慢指针走1步，如果没有环，那么快指针会==null，如果有环，那么快指针和慢指针在环里边转圈，不超过两圈，一定会相遇。<br>当在环中快慢指针相遇时，慢指针停留原地，快指针返回起点，然后共同前进（一次一步），他们一定会在环形入口处相遇。（数学证明：）  </p><ul><li><p>二叉树迭代遍历</p><ul><li>先序：准备一个栈，根节点入栈，循环（栈顶弹出一个r，访问处理r，r的右孩进栈，r的左孩进栈）。</li><li>中序：准备一个栈，（左边界全部入栈，弹出过程中，访问），对每次弹出节点，让他的右边子树重复上述步骤。</li><li>后序：准备两个栈，根节点入栈，循环（栈顶弹出一个r，r放到收集栈，r左孩入栈，r右孩入栈）打印收集栈。</li><li>宽度优先：用队列。循环（打印，队列放左孩子，队列放右孩子）。求最大宽度时，准备一张HashMap&lt;Node,int&gt;（二版不需要，leetcode用hashmap内存超限，662记录了详细操作），记录每个节点在第几层（进栈时记录）。同时设置三个变量：1.cur：记录当前层数。2.curNode：当前层几个节点。3.max哪一层节点数最多。r然后更新</li></ul></li><li><p>树的DP问题：<br>当遇到判断是否是满二叉树等树类型的dp问题的时候，可以用如下套路解决：</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局部最小值问题</title>
      <link href="/2021/12/01/ju-bu-zui-xiao-zhi-wen-ti/"/>
      <url>/2021/12/01/ju-bu-zui-xiao-zhi-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h1><p>现在有一数组arr，无序，任意相邻两数不等。定义规则：局部最小。即arr[0]&lt;arr[1]，那么0位置上为局部最小，arr[n-1]&lt;arr[n-2]，那么n-2位置上局部最小，arr[i]&lt;arr[i-1]、arr[i]&lt;arr[i+1],那么arr[i]局部最小。<br>要求找出一个局部最小位置，时间复杂度能不能好于O(n)？</p><h1 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h1><ul><li>无序也可以二分，观察数据情况，只要确定有一边和问题有关，并能够甩掉一边，就可以进行二分了。</li><li><ol><li>如果arr[0]&lt;arr[1]，直接返回arr[0]，否则0~1数据是降序的。</li></ol></li><li><ol start="2"><li>如果arr[n-1]&lt;arr[n-2]，直接返回arr[n-1]，否则n-1~n-2数据是降序的。</li></ol></li><li><ol start="3"><li>推断：如果两端数据向中间的趋势都是降序的，那么在中间某位置，必然存在一个局部最小值</li></ol></li><li><ol start="4"><li>取中间某数m，若arr[m]&lt;arr[m-1]且arr[m]&lt;arr[m+1]，那么arr[m]为局部最小值。</li></ol></li><li><ol start="5"><li>否则：若arr[m]&gt;arr[m-1]，那么重复3（范围0<del>m）；若arr[m]&lt;arr[m-1]，那么重复3（范围m</del>n-1）<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int findPeakElement(int[] nums) &#123;        int N&#x3D; nums.length-1;        if (N&#x3D;&#x3D;0)&#123;            &#x2F;&#x2F;如果只有一个数            return 0;        &#125;        if(nums[0]&gt;nums[1])&#123;            &#x2F;&#x2F;认为0位置是峰值            return 0;        &#125;        else if(nums[N]&gt;nums[N-1])&#123;            &#x2F;&#x2F;认为末位置是峰值            return N;        &#125;        else &#123;            &#x2F;&#x2F;两端数据为升序，那么必然在中间存在峰值            int before&#x3D;0,last&#x3D;N;            return TwoDis(nums, before, last);        &#125;    &#125;    public int TwoDis(int[]nums, int before, int last)&#123;        int mid&#x3D;(before+last)&#x2F;2;        if(nums[mid]&gt;nums[mid-1] &amp;&amp; nums[mid]&gt;nums[mid+1])&#123;            return mid;        &#125;        else if (nums[mid]&lt;nums[mid-1])&#123;            return TwoDis(nums,before,mid);        &#125;        else if(nums[mid]&lt;nums[mid+1])&#123;            return TwoDis(nums,mid,last);        &#125;        return -1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>此题目与leetcode162寻找峰值相同。  <pre><code>info解答成功:执行耗时:0 ms,击败了100.00% 的Java用户内存消耗:38.3 MB,击败了8.54% 的Java用户</code></pre>在时间上已经是最优化，可能因为递归的原因占用内存较大。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种交换位置的方法+面试题</title>
      <link href="/2021/12/01/yi-chong-jiao-huan-wei-zhi-de-fang-fa/"/>
      <url>/2021/12/01/yi-chong-jiao-huan-wei-zhi-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;交换arr[i]和arr[j]的内容arr[i]&#x3D;arr[i]^arr[j];   arr[j]&#x3D;arr[i]^arr[j];   arr[i]&#x3D;arr[i]^arr[j];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通过以上三次异或运算，就可以使两个变量相互交换。"><a href="#通过以上三次异或运算，就可以使两个变量相互交换。" class="headerlink" title="通过以上三次异或运算，就可以使两个变量相互交换。  "></a>通过以上三次异或运算，就可以使两个变量相互交换。  </h2><p>原因：异或运算（位上相同为0，不同为1），又称为无进位相加。有以下两个性质：</p><ul><li><p>0^N=N、N^N=0</p></li><li><p>满足交换律，结合律。<br><img src="%E4%B8%80%E7%A7%8D%E4%BA%A4%E6%8D%A2%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95/%E6%89%8B%E5%86%99%E9%A2%98%E8%A7%A3.PNG"><br>使用这个方法要保证内存不相同，如果两个变量的内存是一块地址，那么就会出错(会使这个值变成0)  </p><h1 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h1><p>问题：<br>（1）数组中有一种数出现了奇数次，其他的数都出现了偶数次。求这个奇数<br>（2）数组中有两种数出现了奇数次，其他的数都出现了偶数次。求这个偶数<br>（3）要求时间复杂度O(n)，并使用有限个变量，空间O(1)。<br>解答：<br>（1）当一种数出现奇数次时：我们可以设定一个变量为EOR=0，然后遍历数组，用EOR和每个数都进行异或操作，当整个流程完毕，EOR=出现奇数次的数（利用性质1）  </p><pre class="line-numbers language-none"><code class="language-none">public static void printOddTimesNum1(int[]arr)&#123;        int eor&#x3D;0;        for (int cur : arr) &#123;            eor ^&#x3D; cur;        &#125;        System.out.println(&quot;出现奇数次的数为&quot;+eor);    &#125;&#96;&#96;&#96;  ---(2)当有俩种数出现奇数次时，假设一个为A，另一个为B，我们可以设定一个变量为EOR1&#x3D;0，然后遍历数组，用EOR和每个数都进行异或操作，当整个流程完毕，EOR1&#x3D;A^B（利用性质1）  并且这时EOR1!&#x3D;0（因为A!&#x3D;B并且都出现奇数次）。  假设EOR1第8位为1，我们可以设定一个变量为EOR2&#x3D;0，EOR2继续异或数组，但是只异或第八位不是1的那些数。结束后，EOR2&#x3D;A或者EOR2&#x3D;B。  最后，用EOR^EOR2，会得到另一个值。  解释：由于最后第八位为1（假设，可以是第n位），必然A的第八位为1，B的第八位为0，（或A的第八位为0，B的第八位为1），EOR2只异或第八位为0的，必然能够得到一个A或B，然后用EOR^EOR2必然得到另一个。  ![](一种交换位置的方法&#x2F;找两个出现奇数次的数.PNG)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//(2)数组中有两种数出现了奇数次，其他的数都出现了偶数次。求这个偶数<br>  public static void printOddTimesNum2(int[]arr){</p><pre><code>  int eor=0;  int eor2=0;  for (int cur : arr) &#123;      eor ^= cur;  &#125;  //此时eor=A^B  //因为eor！=0，所以eor必有一位为1  int rightOne=eor&amp;(~eor+1);  //提取出一个数，这个数的二进制形式为最右侧的1+00……    for (int cur : arr) &#123;      if ((cur &amp; rightOne) == 0) &#123;          eor2 ^= cur;      &#125;  &#125;  System.out.println(eor2+&quot; &quot;+(eor^eor2));</code></pre><p>  }<br><code>   有一行代码特殊：</code>int rightOne=eor&amp;(~eor+1);  //提取出一个数，这个数的二进制形式为最右侧的1+00……```位运算把一个不等于0的数的最右侧的1提取出来的常规操作。<br><img src="%E4%B8%80%E7%A7%8D%E4%BA%A4%E6%8D%A2%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95/%E6%8F%90%E5%8F%96%E6%9C%80%E5%8F%B3%E4%BE%A71%E6%93%8D%E4%BD%9C.PNG">  </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0002-子矩阵的最大累加和</title>
      <link href="/2021/11/27/0002-zi-ju-zhen-de-zui-da-lei-jia-he/"/>
      <url>/2021/11/27/0002-zi-ju-zhen-de-zui-da-lei-jia-he/</url>
      
        <content type="html"><![CDATA[<h1 id="在一个矩阵中，选取一个子矩阵，使得子矩阵的累加和为最大"><a href="#在一个矩阵中，选取一个子矩阵，使得子矩阵的累加和为最大" class="headerlink" title="在一个矩阵中，选取一个子矩阵，使得子矩阵的累加和为最大"></a>在一个矩阵中，选取一个子矩阵，使得子矩阵的累加和为最大</h1><p><strong>左程云引例</strong></p><p>分析：暴力解法的数量级是N6，因为选取子矩阵左上角N2，选取矩阵右下角是N2，所以固定一个子矩阵是N4，计算累加和为N2，整体数量级是N6.<br>延申：这是最大连续子数组的累加和演变而来的</p><h2 id="连续子数组累加和最大问题"><a href="#连续子数组累加和最大问题" class="headerlink" title="连续子数组累加和最大问题"></a>连续子数组累加和最大问题</h2><p>一个典型的动态规划题目，但是可以用某些技巧来解决。  </p><ul><li>设置两个变量cur、max_result，cur用于累加，max时刻捕获更大的cur值</li><li>cur+=arr[i]  max_result=max(max,cur)</li><li>如果cur小于0，那么置cur为0，否则cur不变<br>以上过程中，实际上是不定头的进行累加，知道选取出一个最大的累加值来。并且可以添加一个变量来记录最近的设为0的位置，即是开始，另一个变量记录结束时的位置<br>考虑：如果数组中全部为负数的时候呢？<br>分析：因为max是跟踪cur的更大的值，当cur为负数时，会被置0，然后选取下一个，所以此流程依然适用于全是负数的情况。  </li></ul><hr><p>发现有两条性质：（假设i~j是累加和最大且最长的连续子数组）（证明为什么对）  </p><ul><li>任何以i开头的连续子数组的前缀都是不小于0的，否则就抛弃了</li><li>任何以i-1为后缀的连续子数组的累加和是小于0的（当累加到i-1的时候，current值一定为0（或者被清零））</li></ul><hr><p>代码示例：</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int maxSubArray(int[] nums) &#123;        int max_result&#x3D;Integer.MIN_VALUE;        int current&#x3D;0;        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;            current+&#x3D;nums[i];            max_result&#x3D;Math.max(max_result,current);            if (current&lt;0)&#123;                current&#x3D;0;            &#125;        &#125;        return max_result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此题解内存消耗44M，只超过37%的提交用户，没有考虑到关于空间复杂度的优化部分。<br>DP解法：（待完善）<br>##原问题：求子矩阵的最大累加和问题</p><ul><li>必须包含第0行，且只包含第0行时（转换为数组最大累加和问题）</li><li>必须包含01行，且只包含01两行的最大矩阵累加和问题。<br>如果仅仅要求包含01两行，可以先纵向累加，然后会得到一个一维数组，实际上是求这个一位数组的最大累加和</li><li>如果只包含0123时……<br>首先进行列累加，会得到一个一维数组，然后求最大累加和</li><li>经过以上处理，那么就会将二维数组的最大累加和问题转换为一位数组的最大累加和问题<br>然后进行行的组合，依次找出不同行的最大累加和，然后最终找出最大累加和，以下是初次版本的代码示例：  <pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[] getMaxMatrix(int[][] matrix) &#123;        int max_result&#x3D;Integer.MIN_VALUE;&#x2F;&#x2F;最大累加和        int[] coordinate &#x3D; new int[4];&#x2F;&#x2F;结果坐标存储在一维数组中        int[] curs &#x3D; new int[matrix[0].length]; &#x2F;&#x2F;存储压缩后的一维数组        int temp_max_result&#x3D;Integer.MIN_VALUE;  &#x2F;&#x2F;连续子数组的最大累加和        int temp_max_result_temp&#x3D;Integer.MIN_VALUE; &#x2F;&#x2F;求最大连续子数组过程中临时变量        int star_temp&#x3D;0;  &#x2F;&#x2F;连续数组开始坐标        int fin_temp&#x3D;0;  &#x2F;&#x2F;连续数组结束坐标        int star&#x3D;0;  &#x2F;&#x2F;连续数组开始坐标        int fin&#x3D;0;  &#x2F;&#x2F;连续数组结束坐标        &#x2F;&#x2F;从第0行开始，选择可以组合的行列0，01，012....1，12，123......2,23,234....        for (int i &#x3D; 0; i &lt; matrix.length; i++) &#123;            for (int j &#x3D; i; j &lt; matrix.length ; j++) &#123;                &#x2F;&#x2F;现在选择了i行到j行，累加为一维数组                for (int k &#x3D; 0; k &lt; matrix[0].length; k++) &#123;                    &#x2F;&#x2F;进行累加和                    for (int n &#x3D; i; n &lt;&#x3D; j; n++) &#123;                        curs[k] +&#x3D; matrix[n][k];                    &#125;                &#125;                &#x2F;&#x2F;得到一维数组curs[k]，是二维矩阵压缩（纵向累加）后的一维数组                &#x2F;&#x2F;接下来计算一维数组curs数组的最大连续子数组                for (int k &#x3D; 0; k &lt; matrix[0].length; k++) &#123;                    &#x2F;&#x2F;如何记录最大值的开始的位置？                    if(temp_max_result_temp&lt;0)&#123;                        temp_max_result_temp&#x3D;curs[k];                        star_temp&#x3D;k;                        fin_temp&#x3D;k;                    &#125;                    else &#123;                        temp_max_result_temp+&#x3D;curs[k];                        fin_temp&#x3D;k;                    &#125;                    if(temp_max_result&lt;temp_max_result_temp)&#123;                        temp_max_result&#x3D;temp_max_result_temp;                        &#x2F;&#x2F;保存位置变量                        star&#x3D;star_temp;                        fin&#x3D;fin_temp;                    &#125;                &#125;                &#x2F;&#x2F;以上一轮for计算完毕后会得到i~j压缩后的最大连续子数组                if(max_result&lt;temp_max_result)&#123;                    max_result&#x3D;temp_max_result;                    coordinate[0]&#x3D;i;                    coordinate[1]&#x3D;star;                    coordinate[2]&#x3D;j;                    coordinate[3]&#x3D;fin;                &#125;                &#x2F;&#x2F;变量初始化                temp_max_result_temp&#x3D;Integer.MIN_VALUE;                for (int k &#x3D; 0; k &lt; matrix[0].length; k++) &#123;                    curs[k]&#x3D;0;                &#125;                star_temp&#x3D;0;                fin_temp&#x3D;0;            &#125;        &#125;        return coordinate;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><p>反馈结果并不理想：<br>执行耗时:1515 ms,击败了5.03% 的Java用户<br>内存消耗:43.1 MB,击败了37.74% 的Java用户<br>因此需要进行优化。</p><h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><ul><li>可以用行累加方法代替每次逐行累加求解（缩小时间消耗）<br>（待更新）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 技巧应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱构建与个人观点</title>
      <link href="/2021/11/26/zhi-shi-tu-pu-gou-jian-zong-shu-yu-ge-ren-guan-dian/"/>
      <url>/2021/11/26/zhi-shi-tu-pu-gou-jian-zong-shu-yu-ge-ren-guan-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="知识图谱构建相关综述与实践"><a href="#知识图谱构建相关综述与实践" class="headerlink" title="知识图谱构建相关综述与实践"></a>知识图谱构建相关综述与实践</h1><hr><pre class="line-numbers language-none"><code class="language-none">1. 科研承担任务：知识图谱的构建，其中知识表示、知识形式化、知识推理部分以及标准制定等由其他人完成。2. 知识图谱的构建涉及知识建模、关系抽取、图存储、关系推理、实体融合等多方面技术。3. 知识图谱的应用则体现在语义搜索、智能问答、语言理解、决策分析等多个领域。我们主要运用在决策分析和预测方面。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2020-11-26更新"><a href="#2020-11-26更新" class="headerlink" title="2020.11.26更新"></a>2020.11.26更新</h2><hr><p>此前已经阅读过非常多的中外文献，首先是以事理图谱为切入点进行研究，但是发现起点太高，知识图谱还没有搞明白。经过自我批评和反省，后来改变策略，要在知识图谱方面进行一定的学习和创新。<br>偶然间发现并阅读了魔图互联（motuhulian.com）关于知识图谱的内容，在这个网站中，对这知识图谱的原理以及目前来说比较成熟的构建技术做出了详细的说明。  </p><hr><h3 id="首次实践"><a href="#首次实践" class="headerlink" title="首次实践"></a>首次实践</h3><hr><p>根据描述，下载安装了Neo4j图形数据库桌面版并进行了使用。前几日组会，Dr.Du举例了关于人与狗相处的事件，深入思考分析这个事件，会得到以下几种实体、属性、关系等内容。这个步骤以后会交给NLP来完成或者相关的DL、ML技术来完成。起步阶段，由人工进行分析，建库。</p><ul><li>实体：或称本体，是客观存在并和区别的事物，可以是人、事、物，或者是抽象的概念，是最基本的要素。  <pre class="line-numbers language-none"><code class="language-none">本例子中包含实体：人、狗、张三、李四、狗三、狗四<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>关系：表示不同实体之间的某种联系  <pre class="line-numbers language-none"><code class="language-none">本例子中，张三李四属于人类，张三是李四朋友。狗三狗四属于狗类，狗三的主人是张三，狗四的主人是李四，张三的狗咬李四等关系。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>属性：知识图谱中实体和关系都可以有各自的属性  <pre class="line-numbers language-none"><code class="language-none">1实体的属性：人的属性、张三的属性。2关系的属性：朋友的属性、狗咬人的属性等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><hr><p>由此，确定了基本的概念和相关定义，接下来在Neo4j中创建知识图谱。(Neo4j采用Cypher语言进行操作库)  </p><ol><li>首先，新建一个Neo4j数据库。我们删除数据库中以往的图，确保一个空白的环境进行操作：<pre class="line-numbers language-none"><code class="language-none">MATCH (n) DETACH DELETE n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这里，MATCH是匹配操作，而小括号()代表一个节点node（可理解为括号类似一个圆形），括号里面的n为标识符。  </li><li>接着，创建实体节点：<pre class="line-numbers language-none"><code class="language-none">CREATE (n:Person &#123;name:&#39;人类&#39;&#125;) RETURN nCREATE (n:Dog &#123;name:&#39;狗类&#39;&#125;) RETURN nCREATE (n:Person &#123;name:&#39;张三&#39;&#125;) RETURN nCREATE (n:Person &#123;name:&#39;李四&#39;&#125;) RETURN nCREATE (n:Dog &#123;name:&#39;狗三&#39;,Traits:&#39;温顺&#39;&#125;) RETURN nCREATE (n:Dog &#123;name:&#39;狗四&#39;,Traits:&#39;狂暴&#39;&#125;) RETURN n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>CREATE是创建操作，Person是标签，代表节点的类型。花括号{}代表节点的属性，属性类似Python的字典。这条语句的含义就是创建一个标签为Person的节点，该节点具有一个name属性，属性值是John。</li></ol><p>然后增加关系</p><pre class="line-numbers language-none"><code class="language-none">MATCH (a:Person &#123;name:&#39;张三&#39;&#125;),       (b:Person &#123;name:&#39;人类&#39;&#125;) MERGE (a)-[:BELONG]-&gt;(b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以此类推，然后进行丰富，最终形成如下知识图谱。</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> 构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法0001:MAX[左]-MAX[右]</title>
      <link href="/2021/11/25/0001-max-zuo-max-you/"/>
      <url>/2021/11/25/0001-max-zuo-max-you/</url>
      
        <content type="html"><![CDATA[<h1 id="输入一个数组，数组长度大于等于2，将该数组随机的一分为二，分成左数组右数组，求左数组-右数组的绝对值的最大值"><a href="#输入一个数组，数组长度大于等于2，将该数组随机的一分为二，分成左数组右数组，求左数组-右数组的绝对值的最大值" class="headerlink" title="输入一个数组，数组长度大于等于2，将该数组随机的一分为二，分成左数组右数组，求左数组-右数组的绝对值的最大值"></a>输入一个数组，数组长度大于等于2，将该数组随机的一分为二，分成左数组右数组，求左数组-右数组的绝对值的最大值</h1><p><strong>左程云引例</strong></p><h2 id="关键点：左1和右1是必然被划分到左边一组和右边一组的"><a href="#关键点：左1和右1是必然被划分到左边一组和右边一组的" class="headerlink" title="关键点：左1和右1是必然被划分到左边一组和右边一组的"></a>关键点：左1和右1是必然被划分到左边一组和右边一组的</h2><p>解答：</p><p>没有想法的办法：进行遍历，暴力解法。</p><ol><li>遍历数组得到整个数组中最大值</li><li>比较左1和右1谁小，选择小的，划分为一组，数组中的max划分到另一组</li><li>这样，其中一组包含整个数组中最大的max，另一组包含最左/最右中的较小的那个（此时为组中max），得到的max差值就是最大的差值</li></ol><p>代码示例：(急速版本，未进行优化)</p><pre class="line-numbers language-none"><code class="language-none">public class A0001_max_left_max_right &#123;    &#x2F;&#x2F;max左-max右    &#x2F;&#x2F;描述：把一个数组划分为两个，使得max[左]-max[右]的绝对值达到最大    &#x2F;&#x2F;题解：laogou.github.io    public static void main(String[] args) &#123;        int data[]&#x3D;&#123;342,7,7,84,8,2,65,7,37868,2,77,2435,5&#125;;        int max&#x3D;0;        int max2&#x3D;0;        int result&#x3D;0;        for (int i &#x3D; 0; i &lt; data.length; i++) &#123;            if (data[i]&gt;data[max])&#123;                max&#x3D;i;            &#125;        &#125;        &#x2F;&#x2F;此时max已经取得最大的坐标        &#x2F;&#x2F;当max是最后一位时        if (max&#x3D;&#x3D;0)&#123;            &#x2F;&#x2F;从右边找一个大于最后一位数的            for (int i &#x3D; data.length-2; i &gt; 0; i--) &#123;                if(data[i]&gt;data[data.length-1])&#123;                    max2&#x3D;i;   &#x2F;&#x2F;这里得到区间边界值                &#125;            &#125;            result&#x3D;Math.abs(data[max]-data[data.length-1]); &#x2F;&#x2F;这里得到最终结果        &#125;        else if(max&#x3D;&#x3D;data.length-1)&#123;            &#x2F;&#x2F;从左边找一个大于data[0]的数            for (int i &#x3D; 0; i &lt; data.length - 2; i++) &#123;                if(data[i]&gt;data[0])&#123;                    max2&#x3D;i; &#x2F;&#x2F;得到边界                &#125;            &#125;            result&#x3D;Math.abs(data[max]-data[0]);        &#125;        &#x2F;&#x2F;max是中间某个值的情况        else &#123;            if (data[0]&lt;data[data.length-1])&#123;  &#x2F;&#x2F;如果0位的数比较小                &#x2F;&#x2F;从左边到max中间找一个大于data[0]的数                for (int i &#x3D; 0; i &lt; max - 2; i++) &#123;                    if(data[i]&gt;data[0])&#123;                        max2&#x3D;i; &#x2F;&#x2F;得到边界                    &#125;                &#125;                result&#x3D;Math.abs(data[max]-data[0]);            &#125;            else &#123;                &#x2F;&#x2F;从max到右边之间找一个大于data[length-1]的数                for (int i &#x3D; max; i &lt; data.length-1; i++) &#123;                    if(data[i]&gt;data[data.length-1])&#123;                        max2&#x3D;i; &#x2F;&#x2F;得到边界                    &#125;                &#125;                result&#x3D;Math.abs(data[max]-data[0]);            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 业务分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
